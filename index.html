<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rootsage: Ethical Foraging</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase Imports (Required for all React/HTML firebase functionality) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, addDoc, getDoc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase functions globally for the React/Babel script to use
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore,
            doc, setDoc, onSnapshot, collection, query, addDoc, getDoc, updateDoc, deleteDoc
        };
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        /* Custom earthy scrollbar */
        .custom-scroll::-webkit-scrollbar { width: 8px; }
        .custom-scroll::-webkit-scrollbar-thumb { background-color: #457849; border-radius: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background-color: #e5e7eb; }
        .font-inter { font-family: 'Inter', sans-serif; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
</head>
<body class="bg-gray-100 font-inter custom-scroll">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;
        const ReactDOM = window.ReactDOM;

        // --- Firebase Globals (Accessed via window.firebase from the module script) ---
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore,
            doc, setDoc, onSnapshot, collection, query, addDoc, getDoc, updateDoc, deleteDoc } = window.firebase || {};

        // --- Configuration Variables (Provided by Canvas Environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const API_KEY = ""; // Gemini API Key

        // --- Custom Theme/Styles (Using Hex for consistency with user request) ---
        const COLORS = {
            SAND: '#FBF3D4',
            DARK_GREEN: '#1D4520',
            FOREST_GREEN: '#346A3A',
            BROWN: '#7F5539',
        };

        // Utility function to convert File to Base64 for the Gemini API
        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        // --- API Calls (Mocked or real, but contained within this file) ---

        const generateRecipes = async (plantName) => {
            const systemPrompt = `Act as a culinary expert. Generate 3 creative and simple recipes suitable for a home cook using the ingredient: ${plantName}. The response must be a valid JSON array matching the provided schema.`;
            const userQuery = `Generate 3 recipes using ${plantName}.`;
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                recipeName: { type: "STRING" },
                                description: { type: "STRING" },
                                ingredients: { type: "ARRAY", items: { type: "STRING" } }
                            },
                            propertyOrdering: ["recipeName", "description", "ingredients"]
                        }
                    }
                }
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            
            try {
                for (let i = 0; i < 3; i++) {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.ok) {
                        const result = await response.json();
                        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (jsonText) return JSON.parse(jsonText);
                    }
                    if (i < 2) await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
                }
                throw new Error('Failed to fetch recipes after multiple retries.');
            } catch (error) {
                console.error("Gemini Recipe API Error:", error);
                return [];
            }
        };

        const diagnosePlant = async (base64Image, prompt) => {
            const systemPrompt = "You are the Rootsage Plant Doctor. Analyze the provided image of a plant. If a disease is detected, identify it and provide clear, actionable care instructions (how to treat it and prevent recurrence). If no disease is detected, confirm the plant is healthy and provide general care tips.";
            const userQuery = `Diagnose the health of this plant based on the image: ${prompt}`;
            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: userQuery },
                        { inlineData: { mimeType: "image/png", data: base64Image } }
                    ]
                }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;

            try {
                for (let i = 0; i < 3; i++) {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.ok) {
                        const result = await response.json();
                        return result.candidates?.[0]?.content?.parts?.[0]?.text || "Diagnosis failed. Please try a clearer image.";
                    }
                    if (i < 2) await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
                }
                throw new Error('Diagnosis failed after multiple retries.');
            } catch (error) {
                console.error("Gemini Doctor API Error:", error);
                return "An error occurred while connecting to the Plant Doctor service. Check your network or API key.";
            }
        };


        // --- Data Models and Logic ---

        const defaultProfile = {
            bio: "Aspiring botanist and green thumb!",
            profilePicUrl: "https://placehold.co/100x100/34D399/ffffff?text=U",
            lastUpdated: new Date().toISOString()
        };

        const getBadgeTier = (count) => {
            if (count > 15) return { name: "Master Botanist", color: "bg-amber-500", icon: "🌱", nextTier: 16 };
            if (count > 5) return { name: "Green Thumb Apprentice", color: "bg-green-600", icon: "🌿", nextTier: 16 };
            return { name: "Novice Gardener", color: "bg-gray-500", icon: "✨", nextTier: 6 };
        };

        const MOCK_SEASONAL_QUESTS = [
            { id: 'q1', name: 'Spring Quest: Harvest Ramps (Wild Leeks)', isSeasonal: true, requiredCollectible: 'Wild Leek', status: 'In Progress', caution: true, badge: '🧄' },
            { id: 'q2', name: 'Summer Quest: Spruce Tip Sugar', isSeasonal: true, requiredCollectible: 'Spruce Tip', status: 'Completed', caution: false, badge: '🌲🍯' },
            { id: 'q3', name: 'Autumn Quest: Identify Edible Mushrooms', isSeasonal: true, requiredCollectible: 'Mushroom', status: 'Locked', caution: true, badge: '🍄' },
            { id: 'q4', name: 'Year-Round: Identify 10 Different Fungi', isSeasonal: false, requiredCollectible: 'Fungi', status: 'In Progress', caution: false, badge: '🦠' },
        ];

        // --- Icons (Inline SVG) ---

        const Icon = ({ d, className = "w-6 h-6" }) => (
            <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" xmlns="http://www.w3.org/2000/svg">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={d} />
            </svg>
        );

        const CameraIcon = (props) => <Icon {...props} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.86-1.503A2 2 0 0111.07 4h1.86a2 2 0 011.664.89l.86 1.503a2 2 0 001.664.89H21a2 2 0 012 2v9a2 2 0 01-2 2H3a2 2 0 01-2-2V9zM12 17a4 4 0 100-8 4 4 0 000 8z" />;
        const LeafIcon = (props) => <Icon {...props} d="M16.5 6v.75m0 3v.75m0 3v.75m0 3v.75M9 10.5l.343-3.084a2.25 2.25 0 014.47-1.077l.51-1.011c.451-.898.156-1.93-.728-2.381A1.65 1.65 0 0012 2.25v2.25M9 10.5h.75m3-.75h.75m-3 .75h.75M16.5 6.75H20.25a.75.75 0 01.75.75V18c0 .414-.336.75-.75.75H3.75a.75.75 0 01-.75-.75V7.5c0-.414.336-.75.75-.75h3.75m9 0h3.75" />;
        const UserIcon = (props) => <Icon {...props} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />;
        const BookIcon = (props) => <Icon {...props} d="M12 6.75h.008v.008H12V6.75zm1.5 6h.008v.008H13.5V12.75zm-3 0h.008v.008H10.5V12.75zm-3 3h.008v.008H7.5V15.75zm3 0h.008v.008H10.5V15.75zm3 0h.008v.008H13.5V15.75zM12 2.25h-5.25A2.25 2.25 0 004.5 4.5v15c0 1.242.755 2.348 1.884 2.76A2.25 2.25 0 008.25 22.5h7.5A2.25 2.25 0 0017.5 20.25v-15A2.25 2.25 0 0015.75 2.25H12zM7 4.5h5" />;
        const HeartIcon = (props) => <Icon {...props} d="M21 8.25c0-2.485-2.015-4.5-4.5-4.5S12 5.765 12 8.25s2.015 4.5 4.5 4.5S21 10.735 21 8.25zM12 18.25c0 2.485-2.015 4.5-4.5 4.5S3 20.735 3 18.25s2.015-4.5 4.5-4.5S12 15.765 12 18.25z" />;
        const CrossIcon = (props) => <Icon {...props} d="M6 18L18 6M6 6l12 12" />;
        const PlusIcon = (props) => <Icon {...props} d="M12 4v16m8-8H4" />;
        const TrophyIcon = (props) => <Icon {...props} d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />;


        // --- Preloader Component ---
        const BouncingLogoPreloader = ({ onAnimationEnd }) => {
            React.useEffect(() => {
                const timer = setTimeout(() => {
                    onAnimationEnd(true);
                }, 3000); // 3 seconds for the bouncing animation
                return () => clearTimeout(timer);
            }, [onAnimationEnd]);

            return (
                <div style={{ backgroundColor: COLORS.DARK_GREEN }} className="fixed inset-0 flex flex-col items-center justify-center z-50 transition-opacity duration-500">
                    <style>
                        {`
                        @keyframes bounce {
                            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
                            40% { transform: translateY(-30px); }
                            60% { transform: translateY(-15px); }
                        }
                        .bouncing-logo { animation: bounce 2s infinite; }
                        `}
                    </style>
                    <div className="bouncing-logo p-4 text-6xl md:text-8xl rounded-full shadow-2xl shadow-green-900/50" style={{ backgroundColor: COLORS.FOREST_GREEN, color: COLORS.SAND }}>
                        🌿
                    </div>
                    <p className="mt-8 text-xl font-bold tracking-wider" style={{ color: COLORS.SAND }}>Rootsage</p>
                    <p className="mt-2 text-sm opacity-70" style={{ color: COLORS.SAND }}>Identifying nature's secrets...</p>
                </div>
            );
        };

        // --- Agreement Gate Component (ToA & Stewardship) ---
        const AgreementGate = ({ onAgree }) => {
            const [isAccepted, setIsAccepted] = useState(false);

            const StewardshipCode = () => (
                <section className="p-6 rounded-xl shadow-lg mb-10 border-t-4 border-red-700 bg-red-50/70">
                    <h2 className="text-xl font-bold mb-4 text-red-700 flex items-center">
                        ⚠️ Edibility & Consumption Agreement
                    </h2>
                    <p className="text-sm leading-relaxed mb-4 text-gray-700">
                        <span className="font-extrabold text-red-800">THIS IS A WARNING:</span> By using the edibility analysis features, you assume all risk. The analysis is for informational purposes only.
                    </p>
                    <ul className="list-disc pl-5 space-y-3 text-sm text-gray-700">
                        <li className="bg-red-100 p-2 rounded-lg border border-red-300">
                            <span className="font-extrabold text-red-800 text-base">100% Certainty is Required:</span> **NEVER** consume a plant unless you are absolutely certain of its identity and edibility. Misidentification can be **FATAL**.
                        </li>
                        <li>
                            <span className="font-semibold text-gray-800">Personal Responsibility:</span> You are responsible for any consumption, preparation, or allergic reactions.
                        </li>
                    </ul>

                    <h2 className="text-xl font-bold mt-8 mb-4 text-green-700 flex items-center">
                        💚 Stewardship Code of Conduct
                    </h2>
                    <p className="text-sm leading-relaxed mb-4 text-gray-700">
                        We advocate for ethical foraging. Please uphold these practices to ensure sustainability:
                    </p>
                    <ol className="list-decimal pl-5 space-y-4 text-sm text-gray-700">
                        <li>
                            <span className="font-extrabold text-green-800 text-base">Take Only What You Need:</span> Never harvest more than 10-15% of a patch.
                        </li>
                        <li>
                            <span className="font-extrabold text-green-800 text-base">Harvest Sustainably:</span> Avoid disturbing roots, bulbs, or the surrounding environment.
                        </li>
                        <li>
                            <span className="font-extrabold text-green-800 text-base">Respect Wildlife:</span> Leave enough for animals that depend on the plant for survival.
                        </li>
                    </ol>
                </section>
            );

            return (
                <div style={{ backgroundColor: COLORS.SAND }} className="min-h-screen p-5 flex flex-col items-center justify-center">
                    <div className="max-w-md w-full">
                        <header className="text-center mb-6">
                            <h1 className="text-4xl font-extrabold" style={{ color: COLORS.FOREST_GREEN }}>Rootsage</h1>
                            <p className="text-base" style={{ color: COLORS.BROWN }}>Ethical Foraging Starts Here</p>
                        </header>

                        <StewardshipCode />

                        <div className="mt-6 p-4 bg-white rounded-xl shadow-lg border border-gray-200">
                            <input
                                type="checkbox"
                                id="agree-check"
                                checked={isAccepted}
                                onChange={(e) => setIsAccepted(e.target.checked)}
                                className="form-checkbox h-5 w-5 text-green-600 rounded focus:ring-green-500"
                            />
                            <label htmlFor="agree-check" className="ml-3 text-sm font-medium text-gray-800">
                                I have read, understand, and agree to the Consumption and Stewardship terms.
                            </label>
                            <button
                                onClick={onAgree}
                                disabled={!isAccepted}
                                className={`mt-4 w-full py-3 rounded-xl text-white font-bold transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed shadow-md ${
                                    isAccepted ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-400'
                                }`}
                            >
                                Enter Rootsage
                            </button>
                        </div>
                    </div>
                </div>
            );
        };


        // --- Nav Bar Component ---

        const NavBar = ({ currentPage, setCurrentPage, badgeCount }) => {
            const badge = getBadgeTier(badgeCount);
            const NavItem = ({ page, icon, label }) => (
                <button
                    onClick={() => setCurrentPage(page)}
                    className={`p-3 flex flex-col items-center justify-center text-xs transition-colors rounded-xl ${
                        currentPage === page
                            ? 'text-white shadow-lg shadow-green-500/50'
                            : 'text-gray-600 hover:text-green-600'
                    }`}
                    style={{ 
                        backgroundColor: currentPage === page ? COLORS.FOREST_GREEN : 'transparent',
                        color: currentPage === page ? COLORS.SAND : COLORS.DARK_GREEN
                    }}
                >
                    {icon}
                    <span className="mt-1 text-[10px] font-medium">{label}</span>
                </button>
            );

            return (
                <div className="fixed bottom-0 left-0 right-0 bg-white shadow-2xl p-2 z-10 border-t border-gray-200">
                    <div className="flex justify-around max-w-lg mx-auto">
                        <NavItem page="identify" label="Identify" icon={<CameraIcon className="w-5 h-5" />} />
                        <NavItem page="doctor" label="Doctor" icon={<HeartIcon className="w-5 h-5" />} />
                        <NavItem page="collectibles" label="Collectibles" icon={<LeafIcon className="w-5 h-5" />} />
                        <NavItem page="journal" label="Journal" icon={<BookIcon className="w-5 h-5" />} />
                        <NavItem page="quests" label="Quests" icon={<TrophyIcon className="w-5 h-5" />} />
                        <NavItem page="profile" label="Profile" icon={<UserIcon className="w-5 h-5" />} />
                    </div>
                    <div className={`absolute top-0 right-2 -translate-y-full px-2 py-1 text-xs font-semibold rounded-t-lg text-white ${badge.color} shadow-lg`}>
                        {badge.icon} {badge.name}
                    </div>
                </div>
            );
        };


        // --- Page Components (Themed) ---

        const IdentifyPlant = ({ userId, db, addCollectible, setCurrentPage }) => {
            const [imageFile, setImageFile] = useState(null);
            const [analysis, setAnalysis] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            const mockPlantAnalysis = (file) => {
                setIsLoading(true);
                setError(null);
                setAnalysis(null);

                const mockData = [
                    { name: "Common Dandelion (Taraxacum officinale)", confidence: "98%", analysis: "A perennial plant. Parts are edible (leaves, flowers, roots), but can be mistaken for toxic species. Edible parts: Flowers (raw/cooked), Leaves (young, raw)." },
                    { name: "Wild Lettuce (Lactuca virosa)", confidence: "75%", analysis: "Contains bitter sap. Caution: Can be mistaken for other wild lactucas. Edible parts: Young leaves (cooked, bitter), Sap (medicinal uses only)." },
                    { name: "Broadleaf Plantain (Plantago major)", confidence: "55%", analysis: "Very common weed. Highly edible and versatile. Edible parts: Young leaves (raw or cooked), Seeds (ground into flour)." }
                ];

                const funFacts = [
                    "The Dandelion flower closes at night and on cloudy days.",
                    "Some types of lettuce were used by the ancient Egyptians.",
                    "Plantain leaves can be chewed and applied to insect bites to soothe irritation."
                ];

                setTimeout(() => {
                    setAnalysis({
                        image: URL.createObjectURL(file),
                        results: mockData.slice(0, 3),
                        funFact: funFacts[Math.floor(Math.random() * funFacts.length)]
                    });
                    setIsLoading(false);
                }, 2000);
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setImageFile(file);
                    mockPlantAnalysis(file);
                }
            };

            const handleAddToCollectibles = () => {
                if (!analysis || !db || !userId) return;

                addCollectible({
                    name: analysis.results[0].name,
                    description: analysis.results[0].analysis,
                    dateIdentified: new Date().toISOString(),
                    imageUrl: analysis.image
                });

                setAnalysis(null);
                setImageFile(null);
                console.log('Plant added to your collectibles! Check out the Quests tab.');
            };

            const handleRetry = () => {
                setAnalysis(null);
                setImageFile(null);
                document.getElementById('file-input').value = '';
            };

            const AnalysisResult = ({ name, confidence, analysis }) => (
                <div className="p-3 bg-gray-50 rounded-lg shadow-inner mb-2 border-l-4 border-green-300">
                    <p className="font-semibold text-gray-800">
                        {name} <span className="text-xs ml-2" style={{ color: COLORS.FOREST_GREEN }}>({confidence} Match)</span>
                    </p>
                    <p className="text-sm text-gray-600 mt-1">{analysis}</p>
                </div>
            );

            return (
                <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                    <h2 className="text-3xl font-bold mb-6" style={{ color: COLORS.DARK_GREEN }}>Identify Nature's Secret</h2>
                    
                    {!analysis && !isLoading && (
                        <div className="bg-white p-6 rounded-xl shadow-lg border-4 border-dashed flex flex-col items-center justify-center h-64" style={{ borderColor: COLORS.FOREST_GREEN + '60' }}>
                            <input
                                type="file"
                                id="file-input"
                                accept="image/*"
                                onChange={handleFileChange}
                                className="hidden"
                            />
                            <label htmlFor="file-input" className="p-4 rounded-full shadow-lg cursor-pointer transition duration-150" style={{ backgroundColor: COLORS.FOREST_GREEN, color: COLORS.SAND, hover: { backgroundColor: COLORS.DARK_GREEN } }}>
                                <CameraIcon className="w-8 h-8" />
                            </label>
                            <p className="mt-4 font-medium" style={{ color: COLORS.DARK_GREEN }}>Tap to take or upload a picture</p>
                        </div>
                    )}

                    {isLoading && (
                        <div className="flex flex-col items-center justify-center h-64 bg-gray-50 rounded-xl shadow-lg">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-500"></div>
                            <p className="mt-4 font-medium" style={{ color: COLORS.FOREST_GREEN }}>Analyzing image...</p>
                        </div>
                    )}

                    {analysis && (
                        <div className="bg-white p-4 rounded-xl shadow-lg border border-green-100">
                            <div className="relative mb-4">
                                <img src={analysis.image} alt="Identified Plant" className="w-full h-48 object-cover rounded-xl border border-gray-200" />
                                <button
                                    onClick={handleRetry} 
                                    className="absolute top-2 right-2 p-2 bg-white/80 text-gray-800 rounded-full shadow-lg hover:bg-white transition"
                                >
                                    <CrossIcon className="w-5 h-5" />
                                </button>
                            </div>
                            
                            <h3 className="text-xl font-bold mb-3" style={{ color: COLORS.FOREST_GREEN }}>Top 3 Potential Matches</h3>
                            
                            <div className="space-y-2">
                                {analysis.results.map((res, index) => (
                                    <AnalysisResult key={index} {...res} />
                                ))}
                            </div>

                            <div className="mt-4 p-3 rounded-lg border-l-4 border-yellow-400" style={{ backgroundColor: '#FFFBEB' }}>
                                <p className="font-semibold text-sm text-yellow-700">Fun Fact:</p>
                                <p className="text-sm text-yellow-800">{analysis.funFact}</p>
                            </div>

                            <div className="flex justify-between mt-6 space-x-3">
                                <button
                                    onClick={handleRetry}
                                    className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 font-semibold rounded-xl hover:bg-gray-300 transition duration-150"
                                >
                                    Retry
                                </button>
                                <button
                                    onClick={handleAddToCollectibles}
                                    className="flex-1 px-4 py-3 text-white font-semibold rounded-xl shadow-md shadow-green-500/50 hover:bg-green-700 transition duration-150"
                                    style={{ backgroundColor: COLORS.FOREST_GREEN }}
                                >
                                    Add to Collectibles
                                </button>
                            </div>
                        </div>
                    )}

                    {error && <p className="mt-4 text-red-500 text-center">{error}</p>}
                </div>
            );
        };

        const Collectibles = ({ collectibles, deleteCollectible }) => {
            const [selectedPlant, setSelectedPlant] = useState(null);
            const [recipes, setRecipes] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [recipeError, setRecipeError] = useState(null);

            const handleGenerateRecipes = useCallback(async (plantName) => {
                setIsLoading(true);
                setRecipeError(null);
                setRecipes(null);
                const result = await generateRecipes(plantName);
                if (result.length > 0) {
                    setRecipes(result);
                } else {
                    setRecipeError("Could not generate recipes. Try again.");
                }
                setIsLoading(false);
            }, []);

            useEffect(() => {
                if (selectedPlant && !recipes) {
                    handleGenerateRecipes(selectedPlant.name);
                }
            }, [selectedPlant, recipes, handleGenerateRecipes]);

            if (selectedPlant) {
                return (
                    <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                        <button onClick={() => setSelectedPlant(null)} className="flex items-center text-green-600 mb-4 font-semibold">
                            <span className="text-xl mr-2">←</span> Back to Collection
                        </button>
                        
                        <h2 className="text-3xl font-bold mb-4" style={{ color: COLORS.DARK_GREEN }}>{selectedPlant.name}</h2>
                        <img src={selectedPlant.imageUrl} alt={selectedPlant.name} className="w-full h-48 object-cover rounded-xl shadow-lg mb-4" />
                        <p className="text-gray-600 mb-4 p-3 bg-gray-50 rounded-lg">{selectedPlant.description}</p>
                        
                        <h3 className="text-2xl font-bold mb-3 border-b pb-1" style={{ color: COLORS.FOREST_GREEN }}>Recipe Suggestions</h3>
                        
                        {isLoading && (
                            <div className="flex items-center justify-center p-8 bg-green-50 rounded-xl">
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-green-500 mr-3"></div>
                                <p className="text-green-700">Generating recipes...</p>
                            </div>
                        )}

                        {recipeError && <p className="text-red-500 text-center p-4 bg-red-50 rounded-xl">{recipeError}</p>}

                        {recipes && recipes.length > 0 && (
                            <div className="space-y-4">
                                {recipes.map((recipe, index) => (
                                    <div key={index} className="p-4 bg-white rounded-xl shadow border border-green-100">
                                        <h4 className="text-lg font-bold" style={{ color: COLORS.FOREST_GREEN }}>{recipe.recipeName}</h4>
                                        <p className="text-sm text-gray-600 mb-2">{recipe.description}</p>
                                        <p className="font-semibold text-gray-700 mt-2">Ingredients:</p>
                                        <ul className="list-disc list-inside text-sm text-gray-500 ml-4">
                                            {recipe.ingredients.map((ing, i) => <li key={i}>{ing}</li>)}
                                        </ul>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                );
            }

            return (
                <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                    <h2 className="text-3xl font-bold mb-6" style={{ color: COLORS.DARK_GREEN }}>My Collection ({collectibles.length})</h2>
                    
                    {collectibles.length === 0 ? (
                        <div className="text-center p-10 bg-gray-50 rounded-xl shadow-inner">
                            <LeafIcon className="w-12 h-12 mx-auto text-green-400" />
                            <p className="mt-4 text-gray-500">No plants identified yet. Get started on the Identify tab!</p>
                        </div>
                    ) : (
                        <div className="grid grid-cols-2 gap-4">
                            {collectibles.map((plant) => (
                                <div
                                    key={plant.id}
                                    onClick={() => setSelectedPlant(plant)}
                                    className="bg-white rounded-xl shadow-lg overflow-hidden cursor-pointer hover:shadow-xl transition duration-200 border border-gray-100"
                                >
                                    <img src={plant.imageUrl} alt={plant.name} className="w-full h-32 object-cover" />
                                    <div className="p-3">
                                        <p className="font-semibold text-sm text-gray-800 truncate">{plant.name}</p>
                                        <p className="text-xs text-gray-400 mt-1">Found: {new Date(plant.dateIdentified).toLocaleDateString()}</p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const PlantDoctor = () => {
            const [imageFile, setImageFile] = useState(null);
            const [base64Image, setBase64Image] = useState(null);
            const [prompt, setPrompt] = useState('');
            const [diagnosis, setDiagnosis] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    setImageFile(URL.createObjectURL(file));
                    const base64 = await fileToBase64(file);
                    setBase64Image(base64);
                }
            };

            const handleDiagnose = async () => {
                if (!base64Image) {
                    setError("Please upload a plant image first.");
                    return;
                }

                setIsLoading(true);
                setError(null);
                setDiagnosis(null);
                const result = await diagnosePlant(base64Image, prompt);
                setDiagnosis(result);
                setIsLoading(false);
            };

            return (
                <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                    <h2 className="text-3xl font-bold text-red-700 mb-6">Rootsage Plant Doctor</h2>
                    <p className="text-gray-600 mb-4">Upload an image of your sick plant for a diagnosis and care advice.</p>
                    
                    <div className="bg-white p-4 rounded-xl shadow-lg">
                        {!imageFile ? (
                            <div className="border-4 border-dashed border-red-300 flex flex-col items-center justify-center h-48 rounded-xl">
                                <input
                                    type="file"
                                    id="doctor-file-input"
                                    accept="image/*"
                                    onChange={handleFileChange}
                                    className="hidden"
                                />
                                <label htmlFor="doctor-file-input" className="p-3 bg-red-600 text-white rounded-full shadow-lg cursor-pointer hover:bg-red-700 transition duration-150">
                                    <CameraIcon className="w-6 h-6" />
                                </label>
                                <p className="mt-2 text-gray-600 text-sm">Upload Photo</p>
                            </div>
                        ) : (
                            <img src={imageFile} alt="Plant for Diagnosis" className="w-full h-48 object-cover rounded-xl border border-gray-200 mb-4" />
                        )}

                        <textarea
                            value={prompt}
                            onChange={(e) => setPrompt(e.target.value)}
                            placeholder="e.g., 'What is wrong with its yellow leaves?'"
                            rows="3"
                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-red-500 focus:border-red-500 mt-4"
                        />

                        <button
                            onClick={handleDiagnose}
                            disabled={isLoading || !base64Image}
                            className={`w-full px-4 py-3 mt-4 font-semibold rounded-xl transition duration-150 ${
                                isLoading || !base64Image
                                    ? 'bg-red-300 cursor-not-allowed'
                                    : 'bg-red-600 text-white shadow-md shadow-red-500/50 hover:bg-red-700'
                            }`}
                        >
                            {isLoading ? 'Diagnosing...' : 'Get Diagnosis'}
                        </button>
                    </div>

                    {error && <p className="mt-4 text-red-500 text-center">{error}</p>}

                    {diagnosis && (
                        <div className="mt-6 p-4 bg-white rounded-xl shadow-lg border-l-4 border-red-500">
                            <h3 className="text-xl font-bold text-red-700 mb-2">Doctor's Report</h3>
                            <div className="prose text-gray-700 text-sm" dangerouslySetInnerHTML={{ __html: diagnosis.replace(/\n/g, '<br>') }} />
                        </div>
                    )}
                </div>
            );
        };

        const Quests = ({ collectibles }) => {
            
            // Check if the user has collected the required item for a quest (mock logic)
            const isQuestCompleted = (requiredCollectible) => {
                if (!requiredCollectible) return false;
                // Simple mock check: if the name contains the required keyword, it's 'collected'
                return collectibles.some(c => c.name.toLowerCase().includes(requiredCollectible.toLowerCase()));
            };

            const allQuests = MOCK_SEASONAL_QUESTS.map(quest => {
                let status = quest.status;
                let badgeEarned = false;

                if (quest.status === 'Completed') {
                    badgeEarned = true;
                } else if (isQuestCompleted(quest.requiredCollectible)) {
                    status = 'Completed';
                    badgeEarned = true;
                } else if (quest.status === 'Locked') {
                    // Keep locked
                } else {
                    status = 'In Progress';
                }

                return { ...quest, status, badgeEarned };
            });

            const QuestCard = ({ quest }) => (
                <div className="bg-white p-4 rounded-xl shadow-md border-l-4 flex flex-col">
                    <div className="flex justify-between items-start mb-2">
                        <h4 className="font-bold text-lg" style={{ color: COLORS.DARK_GREEN }}>
                            {quest.name}
                        </h4>
                        {quest.badgeEarned && <span className="text-3xl ml-3" title="Badge Earned">{quest.badge}</span>}
                    </div>
                    
                    <div className="flex justify-between items-center text-sm">
                        <span className={`px-2 py-1 rounded-full text-xs font-semibold ${
                            quest.status === 'Completed' ? 'bg-green-100 text-green-700' : 
                            quest.caution ? 'bg-yellow-100 text-yellow-700' : 'bg-gray-100 text-gray-700'
                        }`}>
                            {quest.status} {quest.caution && '(High Caution)'}
                        </span>
                        {!quest.badgeEarned && <span className="text-gray-500 italic">Collect: {quest.requiredCollectible}</span>}
                    </div>
                </div>
            );

            return (
                <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                    <h2 className="text-3xl font-bold mb-6" style={{ color: COLORS.DARK_GREEN }}>Seasonal Quests</h2>
                    <p className="text-gray-700 mb-6">Complete foraging challenges to earn unique badges and master the art of ethical harvesting.</p>

                    <div className="space-y-4">
                        {allQuests.map(quest => (
                            <QuestCard key={quest.id} quest={quest} />
                        ))}
                    </div>

                    <h3 className="text-xl font-bold mt-8 mb-4 border-b pb-1" style={{ color: COLORS.FOREST_GREEN }}>My Badges</h3>
                    <div className="flex flex-wrap gap-3">
                        {allQuests.filter(q => q.badgeEarned).map(q => (
                            <div key={q.id} className="text-center p-3 rounded-xl shadow-lg bg-white border border-gray-100">
                                <span className="text-3xl block">{q.badge}</span>
                                <p className="text-xs text-gray-600 mt-1">{q.name.split(':')[1] || 'Badge'}</p>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const Profile = ({ profile, userId, badge }) => {
            const [newBio, setNewBio] = useState(profile.bio);
            const [isEditing, setIsEditing] = useState(false);

            useEffect(() => {
                setNewBio(profile.bio);
            }, [profile.bio]);

            const handleSave = () => {
                // Note: In a full app, this would trigger an updateDoc call to Firebase
                console.log("Saving new bio:", newBio);
                // For this example, we mock the save action
                profile.bio = newBio;
                setIsEditing(false);
            };

            return (
                <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                    <h2 className="text-3xl font-bold mb-6" style={{ color: COLORS.DARK_GREEN }}>My Rootsage Profile</h2>
                    <p className="text-xs text-gray-400 mb-4 break-all">User ID: {userId || "Authenticating..."}</p>

                    <div className="bg-white p-6 rounded-xl shadow-lg flex flex-col items-center">
                        <img
                            src={profile.profilePicUrl}
                            alt="Profile"
                            className="w-24 h-24 rounded-full object-cover border-4 mb-4"
                            style={{ borderColor: COLORS.FOREST_GREEN }}
                        />
                        
                        <h3 className="text-xl font-bold text-gray-800 mb-2">My Bio</h3>
                        
                        {isEditing ? (
                            <>
                                <textarea
                                    value={newBio}
                                    onChange={(e) => setNewBio(e.target.value)}
                                    className="w-full p-2 border border-gray-300 rounded-lg text-sm"
                                    rows="3"
                                />
                                <button onClick={handleSave} className="mt-3 px-4 py-2 text-white font-semibold rounded-xl hover:bg-green-600 transition" style={{ backgroundColor: COLORS.FOREST_GREEN }}>
                                    Save Bio
                                </button>
                            </>
                        ) : (
                            <>
                                <p className="text-gray-600 text-center mb-4 italic">"{profile.bio}"</p>
                                <button onClick={() => setIsEditing(true)} className="text-sm text-green-600 hover:text-green-700 font-medium">
                                    Edit Bio
                                </button>
                            </>
                        )}
                    </div>

                    <div className={`mt-6 p-5 rounded-xl shadow-lg text-white text-center ${badge.color}`}>
                        <p className="text-2xl font-extrabold">{badge.icon} {badge.name}</p>
                        <p className="text-sm mt-1">Identified {profile.collectibleCount} plants.</p>
                        <p className="text-xs mt-2">Identify {badge.nextTier - profile.collectibleCount} more to reach the next tier!</p>
                    </div>
                </div>
            );
        };

        const Journal = ({ journalEntries, addJournalEntry, deleteJournalEntry }) => {
            const [newEntry, setNewEntry] = useState('');
            const [error, setError] = useState('');

            const handleAdd = () => {
                if (newEntry.trim() === '') {
                    setError('Journal entry cannot be empty.');
                    return;
                }
                addJournalEntry(newEntry);
                setNewEntry('');
                setError('');
            };

            const JournalCard = ({ entry }) => (
                <div className="bg-white p-4 rounded-xl shadow-md flex justify-between items-start border-l-4 border-green-500">
                    <div className="flex-1">
                        <p className="text-sm text-gray-800 font-medium">{entry.text}</p>
                        <p className="text-xs text-gray-400 mt-1">
                            {new Date(entry.timestamp).toLocaleDateString()}
                        </p>
                    </div>
                    <button
                        onClick={() => deleteJournalEntry(entry.id)}
                        className="ml-4 p-1 text-red-400 hover:text-red-600 transition"
                    >
                        <CrossIcon className="w-4 h-4" />
                    </button>
                </div>
            );

            return (
                <div className="p-5" style={{ backgroundColor: COLORS.SAND }}>
                    <h2 className="text-3xl font-bold mb-6" style={{ color: COLORS.DARK_GREEN }}>Green Thumb Journal</h2>
                    <div className="bg-white p-4 rounded-xl shadow-inner mb-6">
                        <h3 className="text-lg font-semibold text-gray-700 mb-2">New Initiative</h3>
                        <textarea
                            value={newEntry}
                            onChange={(e) => setNewEntry(e.target.value)}
                            placeholder="e.g., 'Started composting for my tomato plants.'"
                            rows="3"
                            className="w-full p-2 border border-gray-300 rounded-lg focus:ring-green-500 focus:border-green-500 text-sm"
                        />
                        {error && <p className="text-red-500 text-xs mt-1">{error}</p>}
                        <button
                            onClick={handleAdd}
                            className="w-full mt-3 px-4 py-2 text-white font-semibold rounded-xl shadow-md hover:bg-green-700 transition"
                            style={{ backgroundColor: COLORS.FOREST_GREEN }}
                        >
                            <PlusIcon className="w-4 h-4 inline mr-1" /> Add Entry
                        </button>
                    </div>

                    <h3 className="text-xl font-bold text-gray-700 mb-3 border-b pb-1">Past Initiatives</h3>
                    <div className="space-y-3">
                        {journalEntries.length === 0 ? (
                            <p className="text-gray-500 italic text-center p-4">No journal entries yet.</p>
                        ) : (
                            journalEntries
                                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                                .map((entry) => <JournalCard key={entry.id} entry={entry} />)
                        )}
                    </div>
                </div>
            );
        };


        // --- Main App Component ---

        const App = () => {
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [isPreloaderFinished, setIsPreloaderFinished] = useState(false);
            const [hasAgreed, setHasAgreed] = useState(false);
            const [currentPage, setCurrentPage] = useState('identify');
            
            // Data States
            const [collectibles, setCollectibles] = useState([]);
            const [journalEntries, setJournalEntries] = useState([]);
            const [profileData, setProfileData] = useState(defaultProfile);

            // 1. Firebase Initialization and Authentication
            useEffect(() => {
                // Skip initialization if we haven't passed the agreement gate yet
                if (!hasAgreed || !initializeApp) return;

                try {
                    const app = initializeApp(firebaseConfig);
                    const firestore = getFirestore(app);
                    const firebaseAuth = getAuth(app);
                    setDb(firestore);
                    setAuth(firebaseAuth);

                    const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
                        if (user) {
                            setUserId(user.uid);
                        } else {
                            try {
                                if (initialAuthToken) {
                                    await signInWithCustomToken(firebaseAuth, initialAuthToken);
                                } else {
                                    await signInAnonymously(firebaseAuth);
                                }
                            } catch (e) {
                                console.error("Firebase Auth Error:", e);
                                setUserId(crypto.randomUUID());
                            }
                        }
                        setIsAuthReady(true);
                    });

                    return () => unsubscribe();
                } catch (e) {
                    console.error("Firebase Initialization Failed:", e);
                    setIsAuthReady(true);
                    setUserId(crypto.randomUUID());
                }
            }, [hasAgreed]); // Only run after agreement

            // 2. Data Subscriptions (Real-time listeners)
            useEffect(() => {
                if (!db || !userId || !isAuthReady) return;

                const getCollectiblePath = () => `artifacts/${appId}/users/${userId}/collectibles`;
                const getJournalPath = () => `artifacts/${appId}/users/${userId}/journal`;
                const getProfileDoc = () => doc(db, `artifacts/${appId}/users/${userId}/profile`, 'data');

                const unsubCollectibles = onSnapshot(collection(db, getCollectiblePath()), (snapshot) => {
                    const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setCollectibles(items);
                }, (error) => console.error("Collectible Snapshot Error:", error));

                const unsubJournal = onSnapshot(collection(db, getJournalPath()), (snapshot) => {
                    const items = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setJournalEntries(items);
                }, (error) => console.error("Journal Snapshot Error:", error));

                const unsubProfile = onSnapshot(getProfileDoc(), (docSnapshot) => {
                    if (docSnapshot.exists()) {
                        const data = docSnapshot.data();
                        setProfileData(prev => ({ ...prev, ...data, collectibleCount: collectibles.length }));
                    } else {
                        setDoc(getProfileDoc(), defaultProfile, { merge: true }).catch(e => console.error("Error creating profile:", e));
                        setProfileData(prev => ({ ...prev, ...defaultProfile, collectibleCount: collectibles.length }));
                    }
                }, (error) => console.error("Profile Snapshot Error:", error));


                return () => {
                    unsubCollectibles();
                    unsubJournal();
                    unsubProfile();
                };
            }, [db, userId, isAuthReady, collectibles.length]);

            // Update profile data with collectible count whenever collectibles change
            useEffect(() => {
                setProfileData(prev => ({ ...prev, collectibleCount: collectibles.length }));
                if (db && userId) {
                    const profileDocRef = doc(db, `artifacts/${appId}/users/${userId}/profile`, 'data');
                    updateDoc(profileDocRef, { collectibleCount: collectibles.length }).catch(e => console.error("Error updating count:", e));
                }
            }, [collectibles.length, db, userId]);

            // --- CRUD Operations ---

            const addCollectible = async (item) => {
                if (!db || !userId) return;
                const itemWithId = { ...item, timestamp: new Date().toISOString() };
                const path = `artifacts/${appId}/users/${userId}/collectibles`;
                try {
                    await addDoc(collection(db, path), itemWithId);
                } catch (e) {
                    console.error("Error adding collectible: ", e);
                }
            };

            const deleteCollectible = async (id) => {
                if (!db || !userId) return;
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/collectibles`, id);
                try {
                    await deleteDoc(docRef);
                } catch (e) {
                    console.error("Error deleting collectible: ", e);
                }
            };

            const addJournalEntry = async (text) => {
                if (!db || !userId) return;
                const item = { text, timestamp: new Date().toISOString() };
                const path = `artifacts/${appId}/users/${userId}/journal`;
                try {
                    await addDoc(collection(db, path), item);
                } catch (e) {
                    console.error("Error adding journal entry: ", e);
                }
            };

            const deleteJournalEntry = async (id) => {
                if (!db || !userId) return;
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/journal`, id);
                try {
                    await deleteDoc(docRef);
                } catch (e) {
                    console.error("Error deleting journal entry: ", e);
                }
            };

            // Badge Logic
            const badge = useMemo(() => {
                const count = collectibles.length;
                const tier = getBadgeTier(count);
                tier.nextTier = tier.name === "Master Botanist" ? count : tier.name === "Green Thumb Apprentice" ? 16 : 6;
                return tier;
            }, [collectibles.length]);


            // Conditional Rendering Logic
            const renderAppContent = () => {
                // 1. Preloader Screen
                if (!isPreloaderFinished) {
                    return <BouncingLogoPreloader onAnimationEnd={setIsPreloaderFinished} />;
                }

                // 2. Agreement Gate (after preloader)
                if (!hasAgreed) {
                    return <AgreementGate onAgree={() => setHasAgreed(true)} />;
                }
                
                // 3. Main App Content (after agreement and auth check)
                if (!isAuthReady) {
                    return (
                        <div className="flex flex-col items-center justify-center min-h-screen text-green-700" style={{ backgroundColor: COLORS.SAND }}>
                            <div className="animate-pulse text-2xl font-semibold">Loading User Data...</div>
                            <p className="text-sm mt-2 text-gray-500">Securing your garden records.</p>
                        </div>
                    );
                }
                
                const pageProps = { userId, db, collectibles, journalEntries, profile: profileData, badge, addJournalEntry, deleteJournalEntry, deleteCollectible, addCollectible, setCurrentPage };

                let content;
                switch (currentPage) {
                    case 'identify':
                        content = <IdentifyPlant {...pageProps} />;
                        break;
                    case 'collectibles':
                        content = <Collectibles {...pageProps} />;
                        break;
                    case 'doctor':
                        content = <PlantDoctor {...pageProps} />;
                        break;
                    case 'journal':
                        content = <Journal {...pageProps} />;
                        break;
                    case 'quests':
                        content = <Quests {...pageProps} />;
                        break;
                    case 'profile':
                        content = <Profile {...pageProps} />;
                        break;
                    default:
                        content = <IdentifyPlant {...pageProps} />;
                }
                
                return (
                    <div style={{ backgroundColor: COLORS.SAND }} className="min-h-screen font-sans pb-20">
                        <div className="max-w-md mx-auto min-h-screen">
                            <header className="sticky top-0 shadow-md p-4 z-10" style={{ backgroundColor: COLORS.SAND }}>
                                <h1 className="text-3xl font-extrabold text-center" style={{ color: COLORS.DARK_GREEN }}>Rootsage</h1>
                            </header>
                            <main>{content}</main>
                        </div>
                        <NavBar currentPage={currentPage} setCurrentPage={setCurrentPage} badgeCount={collectibles.length} />
                    </div>
                );
            };

            return renderAppContent();
        };

        // Render the application to the root div
        ReactDOM.render(<App />, document.getElementById('root'));

    </script>
</body>
</html>

