<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RootSage Plant Identifier (PWA)</title>
    <!-- PWA Requirements: Define how the app should look on a home screen -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="theme-color" content="#10b981">
    
    <!-- Load Tailwind CSS, React, ReactDOM, and Babel -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel is needed to compile JSX in the browser for this single-file setup -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            collection, 
            query, 
            where, 
            addDoc, 
            getDocs, 
            setDoc, 
            updateDoc, 
            deleteDoc, 
            onSnapshot, 
            serverTimestamp 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";

        // Set Firebase Log Level to Debug
        setLogLevel('Debug');

        // Global Firebase variables will be set here
        window.firebase = {};

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (firebaseConfig) {
            try {
                const app = initializeApp(firebaseConfig);
                const db = getFirestore(app);
                const auth = getAuth(app);

                window.firebase.app = app;
                window.firebase.db = db;
                window.firebase.auth = auth;
                window.firebase.appId = appId;
                window.firebase.serverTimestamp = serverTimestamp;
                
                // Auth initialization
                onAuthStateChanged(auth, async (user) => {
                    if (!user) {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                    // Inform the React app that Firebase is ready
                    window.dispatchEvent(new Event('firebase-ready'));
                });

                // Export Firestore methods for easy access in React
                window.firebase.firestore = {
                    doc, collection, query, where, addDoc, getDocs, setDoc, updateDoc, deleteDoc, onSnapshot
                };

            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        } else {
             console.warn("Firebase configuration not found. Running without persistence.");
             window.dispatchEvent(new Event('firebase-ready'));
        }

    </script>

    <style>
        /* Custom scrollbar styling for a cleaner look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #a7f3d0;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6ee7b7;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            z-index: 50;
        }
        /* Style for the video element to fill the container and look good */
        .camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures video fills the area without distortion */
        }
        /* Style for the canvas used to capture the frame (hidden) */
        .capture-canvas {
            position: absolute;
            top: -9999px;
            left: -9999px;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans antialiased">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, createContext, useContext, useMemo, useCallback, useRef } = React;
        
        // --- Icon Definitions (Inline SVGs) ---
        // Base Icon Component for simplicity
        const BaseIcon = ({ children, className = "w-6 h-6", color = "currentColor" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const IconLeaf = (props) => (
            <BaseIcon {...props}>
                <path d="M11 20A7 7 0 0 1 9.87 9.87c.75-.98 1.81-2.14 2.91-3.23a4 4 0 0 0 5.43 5.43c-1.09 1.09-2.25 2.16-3.23 2.91A7 7 0 0 1 4 13.91" />
                <path d="M16 16a7 7 0 1 0-7-7c0 1.09.25 2.16.75 3.14-.98.75-2.14 1.81-3.23 2.91a4 4 0 0 0 5.43 5.43c1.09-1.09 2.16-2.25 2.91-3.23.98.5 2.05.75 3.14.75Z" />
            </BaseIcon>
        );

        const IconUser = (props) => (
            <BaseIcon {...props}>
                <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
                <circle cx="12" cy="7" r="4" />
            </BaseIcon>
        );

        const IconCamera = (props) => (
            <BaseIcon {...props}>
                <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z" />
                <circle cx="12" cy="13" r="3" />
            </BaseIcon>
        );

        const IconUpload = (props) => (
            <BaseIcon {...props}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="17 8 12 3 7 8" />
                <line x1="12" x2="12" y1="3" y2="15" />
            </BaseIcon>
        );

        const IconHome = (props) => (
            <BaseIcon {...props}>
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
                <polyline points="9 22 9 12 15 12 15 22" />
            </BaseIcon>
        );

        const IconBookOpen = (props) => (
            <BaseIcon {...props}>
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" />
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" />
            </BaseIcon>
        );

        const IconShieldCheck = (props) => (
            <BaseIcon {...props}>
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
                <path d="m9 12 2 2 4-4" />
            </BaseIcon>
        );

        const IconDroplet = (props) => (
            <BaseIcon {...props}>
                <path d="M12 2a8 8 0 0 0-7 14.4c.15.65.65 1.15 1.3 1.3 2.5 1.1 5 1.1 7 0 2.5-.7 4.2-2.3 5.7-4.2A8 8 0 0 0 12 2Z" />
            </BaseIcon>
        );

        const IconSun = (props) => (
            <BaseIcon {...props}>
                <circle cx="12" cy="12" r="4" />
                <path d="M12 2v2" />
                <path d="M12 20v2" />
                <path d="m4.93 4.93 1.41 1.41" />
                <path d="m17.66 17.66 1.41 1.41" />
                <path d="M2 12h2" />
                <path d="M20 12h2" />
                <path d="m4.93 19.07 1.41-1.41" />
                <path d="m17.66 6.34 1.41-1.41" />
            </BaseIcon>
        );

        const IconX = (props) => (
            <BaseIcon {...props}>
                <path d="M18 6 6 18" />
                <path d="m6 6 12 12" />
            </BaseIcon>
        );

        const IconCheck = (props) => (
            <BaseIcon {...props}>
                <path d="M20 6 9 17l-5-5" />
            </BaseIcon>
        );

        const IconSettings = (props) => (
            <BaseIcon {...props}>
                <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1-2 2h-.44a2 2 0 0 0-2 2v.44a2 2 0 0 1 2 2h.44a2 2 0 0 0 2 2v.44a2 2 0 0 1 2 2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-2h.44a2 2 0 0 0 2-2v-.44a2 2 0 0 1 2-2h.44a2 2 0 0 0-2-2v-.44a2 2 0 0 1-2-2h-.44a2 2 0 0 0-2-2v-.44a2 2 0 0 1-2-2h-.44a2 2 0 0 0-2-2z" />
                <circle cx="12" cy="12" r="3" />
            </BaseIcon>
        );

        const IconSearch = (props) => (
            <BaseIcon {...props}>
                <circle cx="11" cy="11" r="8" />
                <path d="m21 21-4.3-4.3" />
            </BaseIcon>
        );

        const IconHeart = (props) => (
            <BaseIcon {...props}>
                <path d="M19 14c1.49-1.46 3-3.23 3-5.5a5.5 5.5 0 0 0-5.5-5.5c-1.8 0-3.4 1-4.3 2.6L12 6l-1.2-2.9C9.4 2.5 7.8 2 6 2a5.5 5.5 0 0 0-5.5 5.5c0 2.27 1.5 4.04 3 5.5L12 22z" />
            </BaseIcon>
        );

        const IconTrash2 = (props) => (
            <BaseIcon {...props}>
                <path d="M3 6h18" />
                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                <line x1="10" x2="10" y1="11" y2="17" />
                <line x1="14" x2="14" y1="11" y2="17" />
            </BaseIcon>
        );

        const IconZap = (props) => (
            <BaseIcon {...props}>
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />
            </BaseIcon>
        );

        const IconCircle = (props) => (
            <BaseIcon {...props}>
                <circle cx="12" cy="12" r="10" />
            </BaseIcon>
        );
        // --- End Icon Definitions ---

        // --- Global State and Constants ---
        const PAGES = {
            SPLASH: 'splash',
            DISCLAIMER: 'disclaimer',
            HOME: 'home',
            CAMERA: 'camera',
            LIBRARY: 'library',
            PROFILE: 'profile',
            STEWARDSHIP: 'stewardship',
            DETAIL: 'detail' // For plant detail view
        };
        
        // AppContext now manages both UI state (currentPage) and Firebase/Auth state
        const AppContext = createContext();

        const useAppState = () => useContext(AppContext);

        // --- Consolidated App Provider ---

        const AppProvider = ({ children }) => {
            // Start directly on HOME to bypass potential issues with initial splash/disclaimer states
            const [currentPage, setCurrentPage] = useState(PAGES.HOME); 
            // NEW STATE: To hold data for the plant currently being viewed
            const [selectedPlant, setSelectedPlant] = useState(null); 
            const [db, setDb] = useState(null); // Firebase State
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);

            // 1. Initialize Firebase services
            useEffect(() => {
                const initializeFirebase = () => {
                    if (window.firebase && window.firebase.db && window.firebase.auth) {
                        setDb(window.firebase.db);
                        setAuth(window.firebase.auth);
                        
                        // Setup Auth State Listener
                        const unsubscribe = window.firebase.auth.onAuthStateChanged((user) => {
                            if (user) {
                                setUserId(user.uid);
                            } else {
                                // Fallback for anonymous login if auth state hasn't resolved to a user
                                setUserId(crypto.randomUUID()); 
                            }
                            setIsAuthReady(true);
                        });
                        return () => unsubscribe();
                    } else {
                        // For non-persisted environment, set a random ID immediately
                        setUserId(crypto.randomUUID());
                        setIsAuthReady(true);
                    }
                };

                // Listen for the custom event fired after Firebase init/auth
                window.addEventListener('firebase-ready', initializeFirebase);
                // Also call once in case the event was fired before the listener was attached
                initializeFirebase();

                return () => {
                    window.removeEventListener('firebase-ready', initializeFirebase);
                };
            }, []);

            const value = useMemo(() => ({
                // UI State
                currentPage,
                setCurrentPage,
                selectedPlant,
                setSelectedPlant, // EXPOSED SETTER
                // Firebase/Data State
                db,
                auth,
                userId,
                isAuthReady,
                appId: window.firebase ? window.firebase.appId : 'default-app-id',
                firestore: window.firebase ? window.firebase.firestore : null,
                serverTimestamp: window.firebase ? window.firebase.serverTimestamp : null
            }), [currentPage, setSelectedPlant, selectedPlant, db, auth, userId, isAuthReady]);

            return (
                <AppContext.Provider value={value}>
                    {children}
                </AppContext.Provider>
            );
        };

        // --- Data Fetching Hooks ---

        const getPath = (db, appId, userId, collectionName, docId) => {
            const firestore = window.firebase.firestore;
            if (!firestore) return null;
            // Private data path: /artifacts/{appId}/users/{userId}/plants/{documentId}
            const path = `artifacts/${appId}/users/${userId}/${collectionName}`;
            return docId ? firestore.doc(db, path, docId) : firestore.collection(db, path);
        };

        const usePlantActions = () => {
            const { db, userId, appId, firestore, serverTimestamp, setSelectedPlant } = useAppState();

            // Function to add a plant and then set it as the selected plant for viewing
            const addPlant = useCallback(async (data) => {
                if (!db || !userId || !firestore) {
                    console.error("Firestore not initialized.");
                    return null;
                }
                try {
                    const collectionRef = getPath(db, appId, userId, 'plants');
                    if (!collectionRef) return null;
                    const newPlant = {
                        ...data,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp(),
                    };
                    const docRef = await firestore.addDoc(collectionRef, newPlant);
                    
                    // Set the newly created plant as selected
                    // We need to simulate the server timestamp for immediate display
                    setSelectedPlant({ ...newPlant, id: docRef.id, createdAt: new Date() });
                    return { ...newPlant, id: docRef.id };
                } catch (e) {
                    console.error("Error adding document: ", e);
                    // Add UI error feedback here
                    return null;
                }
            }, [db, userId, appId, firestore, serverTimestamp, setSelectedPlant]);

            const deletePlant = useCallback(async (plantId) => {
                if (!db || !userId || !firestore) return;
                try {
                    const docRef = getPath(db, appId, userId, 'plants', plantId);
                    if (!docRef) return;
                    await firestore.deleteDoc(docRef);
                } catch (e) {
                    console.error("Error deleting document: ", e);
                }
            }, [db, userId, appId, firestore]);
            
            return { addPlant, deletePlant };
        };

        const useUserPlants = () => {
            const { db, userId, isAuthReady, appId, firestore } = useAppState();
            const [plants, setPlants] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            useEffect(() => {
                if (!db || !isAuthReady || !firestore || !userId) {
                    setLoading(false);
                    return;
                }

                // Path: /artifacts/{appId}/users/{userId}/plants
                const userPlantsCollectionRef = getPath(db, appId, userId, 'plants');
                if (!userPlantsCollectionRef) return;
                const userPlantsQuery = firestore.query(userPlantsCollectionRef);

                const unsubscribe = firestore.onSnapshot(userPlantsQuery, 
                    (snapshot) => {
                        const plantList = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data(),
                            // Ensure createdAt is handled for display
                            createdAt: doc.data().createdAt?.toDate ? doc.data().createdAt.toDate() : new Date(),
                        }));
                        setPlants(plantList);
                        setLoading(false);
                    }, 
                    (err) => {
                        console.error("Error fetching user plants:", err);
                        setError(err);
                        setLoading(false);
                    }
                );

                return () => unsubscribe();
            }, [db, userId, isAuthReady, appId, firestore]);

            return { plants, loading, error };
        };


        // --- Utility Functions ---

        // Function to handle exponential backoff for API calls
        const fetchWithRetry = async (url, options, maxRetries = 5) => {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Check for common API errors like 400 (Bad Request) or 429 (Rate Limit)
                        const errorBody = await response.text();
                        console.error("API Response Error Body:", errorBody);
                        throw new Error(`HTTP error! Status: ${response.status}. Details: ${errorBody.substring(0, 100)}...`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    // Exponential backoff
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 500; // Reduced max delay slightly
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        };
        
        /**
         * Resizes a data URL (image) to a specified maximum width/height and returns the new base64 data.
         * Forces output to JPEG format.
         * @param {string} dataUrl - The original base64 image data URL (e.g., 'data:image/jpeg;base64,...').
         * @param {number} maxWidth - Maximum width for the resized image.
         * @param {number} maxHeight - Maximum height for the resized image.
         * @returns {Promise<{dataURL: string, base64: string, mimeType: string}>} - The resized image data.
         */
        const resizeImage = (dataUrl, maxWidth = 1024, maxHeight = 1024) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                
                img.onerror = (e) => {
                    reject(new Error("Failed to load image for resizing. Invalid data URL."));
                };

                img.onload = () => {
                    let width = img.width;
                    let height = img.height;

                    // Determine scaling factor
                    if (width > height) {
                        if (width > maxWidth) {
                            height *= maxWidth / width;
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width *= maxHeight / height;
                            height = maxHeight;
                        }
                    }

                    // Create canvas for drawing the resized image
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw the image scaled to new dimensions
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert canvas back to data URL, force JPEG for smaller size and compatibility
                    const mimeType = 'image/jpeg';
                    const newQuality = 0.8; // Use 80% quality for good compression
                    const newDataUrl = canvas.toDataURL(mimeType, newQuality);
                    
                    // Extract base64 part
                    const base64Data = newDataUrl.split(',')[1];
                    
                    resolve({
                        dataURL: newDataUrl,
                        base64: base64Data,
                        mimeType: mimeType
                    });
                };
                img.src = dataUrl;
            });
        };

        // --- Components ---

        const LoadingSpinner = ({ message = "Loading..." }) => (
            <div className="flex flex-col items-center justify-center h-full min-h-64 p-8">
                <div className="animate-spin rounded-full h-12 w-12 border-b-4 border-green-600"></div>
                <p className="ml-4 text-gray-500 mt-4 font-medium">{message}</p>
            </div>
        );

        const NavBar = ({ currentPage, setCurrentPage }) => {
            const navItems = [
                { page: PAGES.HOME, icon: IconHome, label: 'Home' },
                { page: PAGES.CAMERA, icon: IconCamera, label: 'Identify' },
                { page: PAGES.LIBRARY, icon: IconBookOpen, label: 'Library' },
                { page: PAGES.STEWARDSHIP, icon: IconHeart, label: 'Stewardship' },
            ];

            return (
                <nav className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-lg z-20">
                    <div className="flex justify-around items-center h-16 max-w-lg mx-auto">
                        {navItems.map(item => {
                            const Icon = item.icon;
                            const isActive = currentPage === item.page;
                            return (
                                <button
                                    key={item.page}
                                    onClick={() => setCurrentPage(item.page)}
                                    className={`flex flex-col items-center p-2 transition-colors duration-200 ${
                                        isActive ? 'text-green-600' : 'text-gray-500 hover:text-green-600'
                                    }`}
                                >
                                    <Icon className="w-5 h-5 mb-0.5" />
                                    <span className="text-xs font-medium">{item.label}</span>
                                </button>
                            );
                        })}
                    </div>
                </nav>
            );
        };

        const HomePage = () => {
            const { setCurrentPage, setSelectedPlant } = useAppState();
            const { plants, loading } = useUserPlants();
            
            // Sort plants by createdAt descending, then show 3 most recent
            const sortedPlants = useMemo(() => {
                if (!plants) return [];
                return plants
                    .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0))
                    .slice(0, 3);
            }, [plants]);

            const mockTips = [
                "Water your fiddle leaf fig when the top inch of soil is dry.",
                "Pinch back basil leaves to encourage bushier growth.",
                "Check for pests like spider mites on the undersides of leaves."
            ];

            const handleViewPlant = (plant) => {
                setSelectedPlant(plant);
                setCurrentPage(PAGES.DETAIL);
            };

            return (
                <div className="p-4 space-y-6 max-w-lg mx-auto">
                    
                    {/* Quick Identify Card */}
                    <div className="bg-white p-6 rounded-2xl shadow-xl border border-green-100">
                        <h2 className="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                            <IconCamera className="w-6 h-6 mr-2 text-green-600"/> Quick Identify
                        </h2>
                        <p className="text-gray-600 mb-4">Tap below to open the identifier. Remember, **direct camera access may be blocked** on GitHub Pages; use the **Upload** option instead.</p>
                        <button
                            onClick={() => setCurrentPage(PAGES.CAMERA)}
                            className="w-full bg-green-600 text-white py-3 rounded-xl font-bold text-lg hover:bg-green-700 transition duration-150 flex items-center justify-center shadow-md shadow-green-300"
                        >
                            <IconCamera className="w-5 h-5 mr-2" />
                            Open Identifier
                        </button>
                    </div>

                    {/* Recent Identifications */}
                    <div className="bg-white p-6 rounded-2xl shadow-xl border border-gray-100">
                        <h2 className="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                            <IconBookOpen className="w-6 h-6 mr-2 text-gray-500"/> Recent Identifications
                        </h2>
                        
                        {loading && <LoadingSpinner message="Loading your library..."/>}

                        {!loading && sortedPlants.length === 0 && (
                            <div className="text-center py-4 text-gray-500">
                                <IconSearch className="w-8 h-8 mx-auto mb-2 text-gray-300"/>
                                <p>Start identifying plants to build your library!</p>
                            </div>
                        )}

                        {!loading && sortedPlants.length > 0 && (
                            <div className="space-y-4">
                                {sortedPlants.map(plant => (
                                    <div 
                                        key={plant.id} 
                                        className="flex items-center p-3 bg-gray-50 rounded-xl hover:bg-gray-100 transition cursor-pointer"
                                        onClick={() => handleViewPlant(plant)} 
                                    >
                                        <div className="w-10 h-10 bg-green-200 rounded-full flex items-center justify-center flex-shrink-0 overflow-hidden">
                                            {/* Placeholder for image */}
                                            <img 
                                                src={plant.imageURL || "https://placehold.co/40x40/a7f3d0/065f46?text=L"} 
                                                alt={plant.name}
                                                className="w-full h-full object-cover"
                                                onError={(e) => {e.target.onerror = null; e.target.src = "https://placehold.co/40x40/a7f3d0/065f46?text=L";}}
                                            />
                                        </div>
                                        <div className="ml-4 flex-grow">
                                            <p className="font-semibold text-gray-800 truncate">{plant.name || 'Unidentified Plant'}</p>
                                            <p className="text-sm text-gray-500">Identified on {new Date(plant.createdAt).toLocaleDateString()}</p>
                                        </div>
                                        <IconX className="w-4 h-4 text-gray-400 ml-2 transform rotate-45"/>
                                    </div>
                                ))}
                                {plants.length > 3 && (
                                    <button 
                                        onClick={() => setCurrentPage(PAGES.LIBRARY)}
                                        className="w-full text-sm text-green-600 font-medium pt-2 hover:text-green-700"
                                    >
                                        View All ({plants.length})
                                    </button>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Gardening Tips */}
                    <div className="bg-white p-6 rounded-2xl shadow-xl border border-gray-100">
                        <h2 className="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                            <IconSettings className="w-6 h-6 mr-2 text-blue-500"/> Daily Gardening Tip
                        </h2>
                        <div className="bg-blue-50 p-4 rounded-xl border border-blue-200">
                            <p className="text-blue-700 italic">"{mockTips[0]}"</p>
                        </div>
                    </div>
                </div>
            );
        };

        const CameraPage = () => {
            const { setCurrentPage } = useAppState();
            const { addPlant } = usePlantActions();

            // Refs for DOM elements
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null); // Keep for "Upload from Library"

            // State for camera management
            const [stream, setStream] = useState(null);
            const [isCameraActive, setIsCameraActive] = useState(false);
            const [permissionError, setPermissionError] = useState(null);

            // State for image data and process
            const [imagePreviewUrl, setImagePreviewUrl] = useState(null);
            const [base64Image, setBase64Image] = useState(null);
            // CRITICAL FIX: Ensure mimeType is always 'image/jpeg' for API
            const [mimeType, setMimeType] = useState('image/jpeg'); 
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);

            // Function to stop the current stream (used for cleanup and before capture)
            const stopCamera = useCallback(() => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    setStream(null);
                }
                setIsCameraActive(false);
            }, [stream]);

            // 1. Setup Camera Stream
            const startCamera = useCallback(async () => {
                // Clear any previous error states and ensure old stream is stopped
                setPermissionError(null);
                stopCamera(); 

                // Check for media devices support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    setPermissionError("Your browser does not support media devices.");
                    setIsCameraActive(false);
                    return;
                }

                try {
                    // Request the environment-facing (back) camera
                    const constraints = { video: { facingMode: { exact: "environment" } } };
                    const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // Attach stream to video element
                    if (videoRef.current) {
                        videoRef.current.srcObject = newStream;
                        // Start playing the video stream
                        videoRef.current.play().catch(e => console.error("Video play failed:", e));
                    }
                    
                    setStream(newStream);
                    setIsCameraActive(true);
                } catch (err) {
                    console.error("Error accessing camera: ", err);
                    // Handle common errors like permission denied or no suitable camera found
                    const msg = err.name === 'NotAllowedError' 
                        ? "Camera access was denied. (Likely blocked by unsecured context - use Upload instead)."
                        : "Camera device not found or inaccessible. Please use the Upload Photo option.";
                    setPermissionError(msg);
                    setIsCameraActive(false);
                }
            }, [stopCamera]);
            
            // Effect to manage camera lifecycle when component mounts or updates
            useEffect(() => {
                // Start camera if we are on the camera page and no image is in preview
                if (!imagePreviewUrl) {
                    startCamera();
                }
                
                // Cleanup function: ensures camera stream is stopped when component unmounts
                return () => {
                   stopCamera();
                };
            }, [startCamera, imagePreviewUrl, stopCamera]); // Added stopCamera dependency

            
            // 2. Image Capture from Live Stream
            const captureImage = async () => {
                if (!videoRef.current || !canvasRef.current || !stream) {
                    setError("Camera not ready. Please wait or check permissions.");
                    return;
                }
                
                // Stop video tracks immediately
                stopCamera(); 

                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                // Set canvas dimensions to match video stream
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                const ctx = canvas.getContext('2d');
                // Draw the current video frame onto the canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // CRITICAL FIX: Use resizeImage to ensure proper JPEG conversion and sizing
                const dataURL = canvas.toDataURL('image/jpeg', 0.9);
                
                try {
                     const resizedData = await resizeImage(dataURL);
                    
                    setImagePreviewUrl(resizedData.dataURL);
                    setBase64Image(resizedData.base64);
                    setMimeType(resizedData.mimeType); // Should be 'image/jpeg'
                    setError(null);
                } catch (e) {
                    setError("Capture failed during image processing.");
                    console.error("Capture image processing error:", e);
                }
            };

            // 3. Image Select from File (Fallback for Gallery Upload)
            const handleFileSelect = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                // Stop camera if it was running
                stopCamera();
                
                // Reset error state
                setError(null);
                setIsLoading(true);

                try {
                    const reader = new FileReader();
                    
                    reader.onloadend = async () => {
                        const originalDataURL = reader.result;
                        
                        // CRITICAL FIX: Client-side Resizing and forcing JPEG conversion
                        const resizedData = await resizeImage(originalDataURL);

                        setImagePreviewUrl(resizedData.dataURL);
                        setBase64Image(resizedData.base64);
                        setMimeType(resizedData.mimeType); // Should be 'image/jpeg'
                        setError(null);
                        setIsLoading(false);
                    };
                    reader.readAsDataURL(file);
                } catch (e) {
                    // Detailed error message for file processing failure
                    setError("Could not process file. Ensure it is a valid image (JPG/PNG).");
                    console.error("File processing error:", e);
                    setIsLoading(false);
                }
            };
            
            // 4. Reset/Clear Photo
            const handleClearPhoto = () => {
                setImagePreviewUrl(null);
                setBase64Image(null);
                // MimeType remains 'image/jpeg' as that is the standard API expectation
                setError(null);
                // Camera will attempt to restart via the useEffect dependency on imagePreviewUrl
            };

            // 5. Trigger File Input for Gallery
            const handleFileClick = () => {
                if (fileInputRef.current) {
                    // Clear the value so selecting the same file triggers onChange
                    fileInputRef.current.value = null; 
                    fileInputRef.current.click(); 
                }
            };

            // 6. Gemini API Call
            const identifyPlant = async () => {
                if (!base64Image || mimeType !== 'image/jpeg') {
                    // Fallback check to ensure data integrity
                    setError("Image data is corrupt or not properly converted to JPEG. Please re-upload."); 
                    return;
                }

                setIsLoading(true);
                setError(null);

                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                const systemPrompt = `You are RootSage, an expert botanical identification and care assistant. Analyze the image and provide the plant's common name, scientific name, and relevant care information. Respond ONLY with a single JSON object that strictly follows the provided schema. Do not add any extra text, markdown, or commentary outside the JSON.`;
                const userQuery = `Identify the plant in this image. Provide the common name, scientific name, a percentage confidence score (between 70% and 99%), whether it is considered toxic to common pets (dogs/cats), and three specific care tips. Also, provide a brief, positive stewardship description (10-15 words).`;

                const payload = {
                    contents: [{
                        parts: [
                            { text: userQuery },
                            // Use the stored base64Image and the guaranteed 'image/jpeg' mimeType
                            { inlineData: { mimeType: mimeType, data: base64Image } } 
                        ]
                    }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                name: { type: "STRING", description: "Common name of the plant (e.g., Fiddle Leaf Fig)." },
                                scientificName: { type: "STRING", description: "Scientific name of the plant (e.g., Ficus lyrata)." },
                                confidence: { type: "STRING", description: "Confidence percentage string (e.g., '95%')." },
                                isToxic: { type: "BOOLEAN", description: "True if toxic to common pets (dogs/cats), false otherwise." },
                                toxicity: { type: "STRING", description: "A brief explanation of toxicity." },
                                careTips: { type: "ARRAY", items: { type: "STRING" }, description: "Three essential care tips." },
                                stewardshipDescription: { type: "STRING", description: "A short, positive description of the plant's value." },
                                imageURL: { type: "STRING", description: "Use the placeholder URL: https://placehold.co/400x300/a7f3d0/065f46?text=Identified+Plant" }
                            },
                            required: ["name", "scientificName", "confidence", "isToxic", "toxicity", "careTips", "stewardshipDescription", "imageURL"]
                        }
                    }
                };

                try {
                    const response = await fetchWithRetry(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (text) {
                        const identifiedData = JSON.parse(text);
                        
                        // 1. Save the identified plant to Firestore
                        const savedPlant = await addPlant(identifiedData);
                        
                        // 2. Navigate to the detail page (addPlant already set selectedPlant)
                        if (savedPlant) {
                            setCurrentPage(PAGES.DETAIL);
                        } else {
                             setError("Identification successful, but failed to save to library. (Firestore error)");
                        }
                    } else {
                        setError("Identification failed. Could not parse response from AI. Response was likely empty or malformed.");
                        console.error("AI Response Error:", result);
                    }
                } catch (e) {
                    // Display the detailed error from fetchWithRetry
                    setError(`API call failed: ${e.message}`);
                    console.error("Fetch/API Error:", e);
                } finally {
                    setIsLoading(false);
                    // Reset to initial state after processing (useEffect will handle camera restart)
                    setImagePreviewUrl(null);
                    setBase64Image(null);
                    // MimeType remains 'image/jpeg'
                }
            };
            
            // --- Render Logic ---
            
            // Decide what to show in the main view area
            let mainContent;

            if (imagePreviewUrl) {
                // Show the static image preview after capture or file upload
                mainContent = (
                    <img src={imagePreviewUrl} alt="Plant Preview" className="w-full h-full object-contain bg-gray-100" />
                );
            } else if (permissionError) {
                // Show permission error message
                mainContent = (
                    <div className="text-center text-red-500 p-4 flex flex-col items-center justify-center h-full">
                        <IconX className="w-10 h-10 mx-auto mb-2"/>
                        <p className="font-semibold text-lg">Camera Unavailable</p>
                        <p className="text-sm mt-1">{permissionError}</p>
                        <button onClick={handleFileClick} className="mt-4 bg-green-600 text-white py-2 px-4 rounded-xl font-semibold flex items-center shadow-md">
                            <IconUpload className="w-4 h-4 mr-1"/> **Upload Photo Instead**
                        </button>
                    </div>
                );
            } else if (isCameraActive) {
                 // Show the live video stream
                mainContent = (
                    <>
                        {/* We use playsInline and autoPlay for better mobile compatibility */}
                        <video ref={videoRef} className="camera-video" playsInline autoPlay />
                        {/* Hidden canvas for image capture */}
                        <canvas ref={canvasRef} className="capture-canvas" />
                    </>
                );
            } else {
                // Initial loading state or waiting for camera stream
                mainContent = <LoadingSpinner message="Requesting camera access..." />;
            }


            return (
                <div className="p-4 flex flex-col items-center max-w-lg mx-auto h-full relative">
                    
                    {isLoading && (
                        <div className="loading-overlay flex items-center justify-center rounded-2xl">
                            <LoadingSpinner message="Analyzing image... please wait."/>
                        </div>
                    )}

                    <h2 className="text-3xl font-bold text-gray-800 mb-4">Identify Plant</h2>
                    <p className="text-gray-600 mb-6 text-center">Use the **Upload Photo from Gallery** option if your camera is blocked.</p>
                    
                    {/* Image/Video Preview Area */}
                    <div className={`w-full h-80 flex items-center justify-center rounded-2xl shadow-xl border-4 transition duration-300 overflow-hidden relative 
                            ${imagePreviewUrl ? 'p-0 border-green-300' : 'bg-gray-100 border-gray-200 p-0'}`}>
                        {mainContent}
                    </div>
                    
                    {/* HIDDEN FILE INPUT (Used ONLY for Gallery Upload) */}
                    <input
                        type="file"
                        ref={fileInputRef} 
                        accept="image/*"
                        onChange={handleFileSelect}
                        className="hidden"
                    />

                    {error && (
                        <div className="mt-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg w-full text-sm">
                            **Error:** {error}
                        </div>
                    )}
                    
                    {/* Action Buttons */}
                    <div className="w-full mt-6 space-y-4">
                        {!imagePreviewUrl ? (
                            // Buttons when live camera is showing or preparing
                            <div className="flex gap-4 items-center justify-center relative">
                                {isCameraActive ? (
                                    <>
                                        {/* Capture Button - Only visible when camera stream is active */}
                                        <button
                                            onClick={captureImage}
                                            className="flex-shrink-0 w-20 h-20 rounded-full border-4 border-white shadow-2xl bg-green-600 text-white hover:bg-green-700 transition duration-150 flex items-center justify-center"
                                        >
                                            <IconCircle className="w-16 h-16 fill-current"/>
                                        </button>
                                        <button
                                            onClick={handleFileClick}
                                            className="absolute right-0 p-3 m-3 rounded-full bg-gray-800 text-white/90 hover:bg-gray-700 shadow-lg"
                                            style={{ bottom: 0, right: '5%'}}
                                        >
                                            <IconUpload className="w-6 h-6" />
                                        </button>
                                    </>
                                ) : (
                                    // Fallback buttons when camera is not active (due to error or user not having camera)
                                    // This set of buttons focuses on the "Upload" fallback when the camera fails
                                    <>
                                        <button
                                            onClick={handleFileClick}
                                            className="flex-1 w-full py-3 rounded-xl font-bold text-lg transition duration-150 flex items-center justify-center shadow-md bg-green-600 text-white hover:bg-green-700"
                                        >
                                            <IconUpload className="w-5 h-5 mr-2" />
                                            Upload Photo from Gallery
                                        </button>
                                    </>
                                )}
                            </div>
                        ) : (
                            // Buttons when image preview is showing (captured or uploaded)
                            <div className="flex gap-4">
                                <button
                                    onClick={identifyPlant}
                                    disabled={isLoading}
                                    className={`flex-1 py-3 rounded-xl font-bold text-lg transition duration-150 flex items-center justify-center shadow-lg ${
                                        !isLoading
                                            ? 'bg-green-600 text-white hover:bg-green-700 shadow-green-400/50'
                                            : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                    }`}
                                >
                                    <IconZap className="w-5 h-5 mr-2" />
                                    {isLoading ? 'Analyzing...' : 'Identify Plant'}
                                </button>
                                <button 
                                    onClick={handleClearPhoto}
                                    disabled={isLoading}
                                    className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-xl font-bold text-lg hover:bg-gray-300 transition duration-150 flex items-center justify-center shadow-md disabled:opacity-50"
                                >
                                    <IconX className="w-5 h-5 mr-2"/> Retake / Clear
                                </button>
                            </div>
                        )}
                    </div>

                </div>
            );
        };


        const PlantDetailPage = () => {
            const { setCurrentPage, selectedPlant, setSelectedPlant } = useAppState();
            const { deletePlant } = usePlantActions();

            // Use the dynamic selectedPlant from context
            const plant = selectedPlant; 

            if (!plant) {
                // Handle case where we navigate here without a selected plant
                useEffect(() => {
                    setCurrentPage(PAGES.HOME);
                }, [setCurrentPage]);
                return <LoadingSpinner message="Redirecting to home..." />;
            }
            
            // Parse care tips if they came as a JSON array (should be array of strings)
            const careTips = Array.isArray(plant.careTips) ? plant.careTips : [];

            const handleDelete = async () => {
                // In a real app, you'd show a modal/dialog for confirmation:
                // if (await showConfirmationModal("Are you sure?")) { ... }
                
                try {
                    await deletePlant(plant.id); 
                    setSelectedPlant(null);
                    setCurrentPage(PAGES.LIBRARY);
                } catch (error) {
                    console.error("Failed to delete plant:", error);
                    // Add UI error feedback
                }
            };

            const StewardshipIcon = IconHeart; 

            return (
                <div className="p-4 max-w-lg mx-auto">
                    <div className="bg-white rounded-2xl shadow-xl overflow-hidden mb-4">
                        {/* Back Button */}
                        <button
                            onClick={() => setCurrentPage(PAGES.LIBRARY)}
                            className="absolute top-5 left-5 p-2 rounded-full bg-black/50 text-white hover:bg-black/70 z-10"
                            aria-label="Back to Library"
                        >
                            <IconX className="w-6 h-6 transform rotate-45"/>
                        </button>

                        {/* Image/Header */}
                        <div className="relative">
                            <img 
                                // Use the placeholder URL provided by the AI response
                                src={plant.imageURL || "https://placehold.co/400x300/e0f2f1/065f46?text=Identified+Plant"} 
                                alt={plant.name} 
                                className="w-full h-64 object-cover"
                                onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/400x300/e0f2f1/065f46?text=Image+Not+Found"; }}
                            />
                        </div>
                        
                        <div className="p-6">
                            <h1 className="text-3xl font-extrabold text-green-700">{plant.name || 'Unidentified'}</h1>
                            <p className="text-lg italic text-gray-500 mb-4">{plant.scientificName || 'Unknown Species'}</p>

                            {/* Key Stats */}
                            <div className="flex justify-between items-center border-t border-b py-3 mb-6">
                                <div className="text-center">
                                    <p className="text-xs font-medium text-gray-500">CONFIDENCE</p>
                                    <p className="text-xl font-bold text-green-600">{plant.confidence || 'N/A'}</p>
                                </div>
                                <div className="text-center">
                                    <p className="text-xs font-medium text-gray-500">TOXIC</p>
                                    <p className={`text-xl font-bold ${plant.isToxic ? 'text-red-500' : 'text-green-500'}`}>
                                        {plant.isToxic ? 'YES' : 'NO'}
                                    </p>
                                </div>
                                <div className="text-center">
                                    <p className="text-xs font-medium text-gray-500">IDENTIFIED</p>
                                    <div className="text-sm font-semibold text-gray-700">
                                        {new Date(plant.createdAt).toLocaleDateString()}
                                    </div>
                                </div>
                            </div>

                            {/* Care Tips */}
                            <h2 className="text-2xl font-bold text-gray-800 mb-3 flex items-center">
                                <IconCheck className="w-5 h-5 mr-2 text-green-600"/> Care Tips
                            </h2>
                            {careTips.length > 0 ? (
                                <ul className="space-y-2 mb-6 list-disc list-inside text-gray-600">
                                    {careTips.map((tip, index) => (
                                        <li key={index} className="text-sm">{tip}</li>
                                    ))}
                                </ul>
                            ) : (
                                <p className="text-gray-500 mb-6 text-sm">No specific care tips found for this identification.</p>
                            )}

                            {/* Stewardship Info */}
                            <h2 className="text-2xl font-bold text-gray-800 mb-3 flex items-center">
                                <StewardshipIcon className="w-5 h-5 mr-2 text-yellow-600"/> Stewardship
                            </h2>
                             <div className="p-4 rounded-xl bg-yellow-50 text-yellow-800 border border-yellow-200 text-sm mb-6">
                                {plant.stewardshipDescription || "No stewardship information available."}
                            </div>

                            {/* Toxicity Info */}
                            <h2 className="text-2xl font-bold text-gray-800 mb-3 flex items-center">
                                <IconDroplet className="w-5 h-5 mr-2 text-red-600"/> Safety/Toxicity
                            </h2>
                            <div className={`p-4 rounded-xl text-sm ${plant.isToxic ? 'bg-red-50 text-red-800 border border-red-200' : 'bg-green-50 text-green-800 border border-green-200'}`}>
                                **Toxicity:** {plant.toxicity || 'Information not provided.'}
                            </div>
                        </div>
                    </div>
                    
                    {/* Actions */}
                    <div className="flex justify-between space-x-4 mb-20">
                        <button
                            onClick={() => setCurrentPage(PAGES.LIBRARY)}
                            className="flex-1 bg-gray-100 text-gray-700 py-3 rounded-xl font-semibold hover:bg-gray-200 transition duration-150 flex items-center justify-center shadow-md"
                        >
                            <IconBookOpen className="w-5 h-5 mr-2"/> Back to Library
                        </button>
                        <button
                            onClick={handleDelete}
                            className="flex-1 bg-red-500 text-white py-3 rounded-xl font-semibold hover:bg-red-600 transition duration-150 flex items-center justify-center shadow-md"
                        >
                            <IconTrash2 className="w-5 h-5 mr-2"/> Delete Record
                        </button>
                    </div>
                </div>
            );
        };
        
        const LibraryPage = () => {
            const { setCurrentPage, setSelectedPlant } = useAppState();
            const { plants, loading } = useUserPlants();
            
            const handleViewPlant = (plant) => {
                setSelectedPlant(plant);
                setCurrentPage(PAGES.DETAIL);
            };

            if (loading) return <LoadingSpinner message="Loading your plant library..." />;

            return (
                <div className="p-4 space-y-4 max-w-lg mx-auto">
                    <h2 className="text-3xl font-bold text-green-700 mb-6">My Plant Library ({plants.length})</h2>
                    
                    {plants.length === 0 ? (
                        <div className="text-center py-16 text-gray-500 bg-gray-50 rounded-xl shadow-inner">
                            <IconBookOpen className="w-10 h-10 mx-auto mb-3 text-gray-300"/>
                            <p className="text-lg font-semibold">No identified plants yet!</p>
                            <p className="text-sm mt-1">Go to the **Identify** tab to start building your library.</p>
                            <button 
                                onClick={() => setCurrentPage(PAGES.CAMERA)}
                                className="mt-6 bg-green-500 text-white py-2 px-4 rounded-lg text-sm font-medium hover:bg-green-600 transition shadow"
                            >
                                Identify My First Plant
                            </button>
                        </div>
                    ) : (
                        <div className="space-y-3">
                            {/* Sort by newest first */}
                            {plants.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0)).map(plant => (
                                <div 
                                    key={plant.id} 
                                    className="flex items-center p-3 bg-white rounded-xl shadow hover:shadow-md transition cursor-pointer border border-gray-100"
                                    onClick={() => handleViewPlant(plant)} 
                                >
                                    <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center flex-shrink-0 overflow-hidden border-2 border-green-300">
                                        {/* Use the placeholder imageURL if available */}
                                        <img 
                                            src={plant.imageURL || "https://placehold.co/48x48/a7f3d0/065f46?text=L"} 
                                            alt={plant.name}
                                            className="w-full h-full object-cover"
                                            onError={(e) => {e.target.onerror = null; e.target.src = "https://placehold.co/48x48/a7f3d0/065f46?text=L";}}
                                        />
                                    </div>
                                    <div className="ml-4 flex-grow">
                                        <p className="font-bold text-gray-800 truncate">{plant.name || 'Unidentified Plant'}</p>
                                        <p className="text-sm text-gray-500">
                                            {plant.scientificName} 
                                            <span className={`ml-2 px-2 py-0.5 text-xs rounded-full font-medium ${plant.isToxic ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>
                                                {plant.isToxic ? 'Toxic' : 'Safe'}
                                            </span>
                                        </p>
                                    </div>
                                    <IconX className="w-4 h-4 text-gray-400 ml-2 transform rotate-45"/>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const PlaceholderPage = ({ title, icon: Icon, description }) => {
            const { setCurrentPage, userId } = useAppState();
            const displayUserId = userId ? `${userId}` : 'N/A';

            return (
                <div className="flex flex-col items-center justify-center p-6 text-center h-full max-w-lg mx-auto">
                    <Icon className="w-16 h-16 text-green-500 mb-4" />
                    <h2 className="text-3xl font-bold text-gray-800 mb-3">{title}</h2>
                    <p className="text-gray-600 mb-8">{description}</p>
                    {title.includes('User') && (
                        <div className="mt-4 p-3 bg-gray-100 rounded-xl break-all">
                            <p className="text-xs font-semibold text-gray-700">Your unique User ID:</p>
                            <p className="text-sm text-gray-500">{displayUserId}</p>
                        </div>
                    )}
                    <button
                        onClick={() => setCurrentPage(PAGES.HOME)}
                        className="mt-6 bg-green-600 text-white py-2 px-6 rounded-xl font-semibold hover:bg-green-700 transition duration-150 shadow-md"
                    >
                        Go to Home
                    </button>
                </div>
            );
        };

        // --- Main App Component ---

        const App = () => {
            const { currentPage, setCurrentPage, isAuthReady, userId } = useAppState(); 

            const renderPage = () => {
                switch (currentPage) {
                    case PAGES.HOME:
                        return <HomePage />;
                    case PAGES.CAMERA:
                        return <CameraPage />;
                    case PAGES.LIBRARY:
                        return <LibraryPage />;
                    case PAGES.PROFILE:
                        return <PlaceholderPage title={`User Profile`} icon={IconUser} description="This page shows your user information for data persistence." />;
                    case PAGES.STEWARDSHIP:
                        return <PlaceholderPage title="Plant Stewardship" icon={IconHeart} description="Learn how to care for plants and contribute to a healthier planet." />;
                    case PAGES.DETAIL:
                        return <PlantDetailPage />;
                    default:
                        return <PlaceholderPage title="Page Not Found" icon={IconX} description="Oops! We can't find the page you're looking for." />;
                }
            };

            // This message will now show instead of a white screen if Firebase auth is still initializing
            if (!isAuthReady) {
                return (
                    <div className="flex flex-col items-center justify-center h-screen bg-gray-50">
                        <LoadingSpinner message="Authenticating and preparing app..."/>
                        <p className="text-sm text-gray-400 mt-4">If this persists, check console for Firebase connection errors.</p>
                    </div>
                );
            }
            
            return (
                <div className="min-h-screen bg-gray-50 flex justify-center">
                    <div className="w-full max-w-lg flex flex-col min-h-screen relative bg-white shadow-xl overflow-hidden">
                        
                        {/* Header only visible on non-critical screens */}
                        {(currentPage !== PAGES.CAMERA) && (
                            <header className="sticky top-0 bg-white p-4 border-b border-gray-200 flex items-center justify-between z-10">
                                <h1 className="text-xl font-bold text-green-700 flex items-center">
                                    <IconLeaf className="w-6 h-6 mr-1" /> RootSage
                                </h1>
                                <button 
                                    onClick={() => setCurrentPage(PAGES.PROFILE)}
                                    className="text-sm text-gray-500 hover:text-green-600 flex items-center"
                                >
                                    <IconUser className="w-4 h-4 mr-1"/> Profile
                                </button>
                            </header>
                        )}

                        {/* Main content area. Removed splash/disclaimer logic. Added padding for navbar */}
                        <main className={`flex-grow overflow-y-auto pb-16`}>
                            {renderPage()}
                        </main>

                        <NavBar currentPage={currentPage} setCurrentPage={setCurrentPage} />
                    </div>
                </div>
            );
        };

        // Ensure the App is rendered after the script is loaded
        ReactDOM.createRoot(document.getElementById('root')).render(<AppProvider><App /></AppProvider>);

    </script>
</body>
</html>

